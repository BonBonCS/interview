# 운영체제

### 강다은
<details>
   <summary> <b>1. </b> 스래싱(Thrashing)이 무엇인지 설명해보세요. </summary> <br />
<div>
  
- 스래싱은 너무 잦은 페이지 교체가 발생하는 현상입니다. <br />
- 계속적으로 페이지 부재가 발생하여 프로세스 처리 시간보다 페이지 교체 시간이 더 많이 발생하는 현상입니다.
</div>
</details>
<br />

<details>
   <summary> <b>2. </b> 메모리 할당 시 최초 적합과 최악 적합에 대해 설명해주세요. </summary> <br />
<div>
  
- 주기억 장치의 사용 가능한 공간 중 처음으로 찾아낸 곳에 데이터를 저장하는 것이 최초 적합입니다.  <br />
- 주기억 장치의 사용 가능한 공간을 모두 비교한 후 가장 큰 공간을 선택하여 데이터를 저장하는 것이 최악 적합입니다.
</div>
</details>
<br />

<details>
   <summary> <b>3. </b> 실행 파일을 만드는 과정을 설명해보세요. </summary> <br />
<div>
  
- 실행가능한 파일은 빌드 과정을 거쳐서 만들어집니다.
- 빌드(Build)는 고급언어와 같이 사용자가 작성한 코드를 컴퓨터가 이해할 수 있는 기계어로 번역하는 과정입니다. <br />
- 빌드 과정은 Compile, Interpreted, Hybrid 크게 세가지 방식이 있습니다. <br />

type|description|
---|---|
Compile|소스코드 전체를 기계어로 번역|
Interpreted| 소스코드를 한 줄씩 번역하면서 실행|
Hybrid| 소스코드 전체를 바이트 코드로 번역한 후, 가상머신에서 한 줄씩 실행|

</div>
</details>
<br />

<details>
   <summary> <b>4. </b> 내부 단편화가 무엇인지 설명해주세요. </summary> <br />
<div>
  
- 주기억장치 내 영역이 실행 프로그램보다 커서 사용 공간 할당 후에 공간이 남게 되는 현상입니다. 
</div>
</details>
<br />

<details>
   <summary> <b>5. </b> 페이지와 프레임을 다른 점을 중심으로 설명해주세요. </summary> <br />
<div>
  
- 페이지는 가상 주소 공간을 일정한 크기로 나누어 관리하는 단위로 모이면 프로세스가 됩니다.  <br />
- 프레임은 물리 메모리를 일정한 크기로 나누어 관리하는 단위로 모이면 메모리가 됩니다.
</div>
</details>
<br />

<details>
   <summary> <b>6. </b> 페이지 교체 알고리즘 중 하나를 설명해주세요. </summary> <br />
<div>
  
- LRU는 최근에 사용하지 않은 페이지를 교체하는 알고리즘입니다. 과거 경험으로 미래의 확률을 추측하는 방식입니다.
</div>
</details>
<br />

<details>
   <summary> <b>7. </b> 동기,비동기와 블로킹,논블로킹 개념을 알고 있나요? 둘의 차이를 설명해주세요. </summary> <br />
<div>
  
- 동기와 비동기는 요청 작업에 대한 완료와 관련해 작업을 순차적으로 수행할지 아닌지에 관점이 있습니다.
- 블로킹과 논블록킹은 현재 작업이 블록되는지 아닌지에 따라 다른 작업을 수행할 수 있는지에 관점이 있습니다.
</div>
</details>
<br />

<details>
   <summary> <b>8. </b> 데드락의 발생조건을 간단하게 말해주세요. </summary> <br />
<div>
  
- 데드락은 상호 배제, 점유 대기, 비선점, 순환대기 4가지 모두를 만족하면 발생합니다.
</div>
</details>
<br />

<details>
   <summary> <b>9. </b> 뮤텍스와 세마포어의 차이를 중점으로 설명해주세요. </summary> <br />
<div>
  
- 뮤텍스는 공유 자원을 보호하기 위해 사용하며, 자원을 점유한 프로세스에 lock을 걸고 반환하기에 다른 스레드가 간섭할 수 없습니다.
- 세마포어는 복수의 공유 자원을 사용하기 위한 시그널로 사용하며, 자원의 허용 상태를 나타내는 변수를 사용하는 것으로 lock과 같은 소유 개념이 없습니다.
- 즉 뮤텍스는 잠금 기반, 세마포어는 신호 기반 매커니즘입니다.
</div>
</details>
<br />


### 이하린
<details>
   <summary> <b>1. </b> 전역 변수와 정적 변수의 차이를 설명해주세요. </summary> <br />
<div>
   
   - `전역 변수`와 `정적 변수`는 다른 파일에서 접근 허용이 가능한지, 생애주기, 사용 범위에 따라 차이점이 존재합니다.
   - `정적 변수`는 해당 함수나 블록이 실행될 때 생성되고 프로그램 소멸까지의 생애주기를 가지지만 `전역 변수`는 프로그램 생성부터 소멸까지의 생애주기를 가집니다.
   - 또, `정적 변수`는 다른 파일에서 접근 허용이 불가능하지만 전역 변수는 가능합니다.
   - 마지막으로 `정적 변수`는 함수 외부에 선언했을 경우 선언된 파일에서, 함수 내부 선언을 했을 경우 중괄호 내부에서 사용이 가능합니다. 하지만, `전역 변수`는 프로그램 전체에서 사용이 가능합니다.

</div>
</details>
<br />

<details>
   <summary> <b>2. </b> 런타임과 컴파일타임에 대한 차이를 설명해주세요. </summary> <br />
<div>
   
   - `컴파일타임`은 컴파일이라는 과정을 통해 기계가 읽을 수 있는 형태로 변환하는 시간이며 코드의 구문 오류 확인과 최적화를 수행합니다.
   - 반면에 `런타임`은 컴파일 타임 이후 컴파일된 코드가 실행되고 동작하는 시간입니다.

</div>
</details>
<br />

<details>
   <summary> <b>3. </b> IPC가 무엇인지 아시나요? 이에 대해 설명해주세요. </summary> <br />
<div>
   
- `IPC`는 프로세스들끼리 통신하며 서로 데이터를 주고 받는 행위를 말합니다.
- 프로세스는 독립되어있어 통신이 힘드므로 커널 영역에서 `IPC`라는 내부 프로세스간 통신을 제공합니다.

</div>
</details>
<br />

<details>
   <summary> <b>4. </b> 가상 메모리에 대해 간단하게 설명해주세요. </summary> <br />
<div>
   
- 물리 메모리보다 큰 프로세스를 수행하기 위해 사용합니다.
- 매모리에 로드된 프로세스가 가상의 메모리 주소를 참조하여 더 큰 메모리를 가지고 있는 것처럼 사용할 수 있게합니다.

</div>
</details>
<br />

<details>
   <summary> <b>5. </b> 페이징 기법에 대해 설명해주세요.  </summary> <br />
<div>
   
- 페이징 기법이란 프로세스를 일정한 크기의 페이지로 분할해서 메모리에 적재하는 방식을 말합니다.
- 이때 페이지란 가상 메모리를 일정한 크기로 나눈 블록입니다.

</div>
</details>
<br />

<details>
   <summary> <b>6. </b> 페이징과 세그멘테이션의 차이는 무엇인가요?  </summary> <br />
<div>
   
- 페이징과 세그멘테이션 모두 프로그램을 실행하기 위해 디스크에 있는 내용을 분할하여 메모리에 적재하는 불연속 메모리 관리 기법입니다.
- 둘의 차이는 프로그램을 분할하는 방식에 있습니다.
- 페이징의 경우, 프로그램을 같은 크기의 페이지로 분할합니다.
- 하지만 세그멘테이션의 경우, 논리적 의미를 기준으로 세그먼트를 분할합니다.

</div>
</details>
<br />

<details>
   <summary> <b>7. </b> 임계영역이 무엇인가요?  </summary> <br />
<div>
   
- 둘 이상의 프로세스, 스레드가 공유 자원에 접근할 때 순서 등의 이유로 코드가 달라지는 영역입니다.
- 코드가 달라지는 것을 방지하기 위해 여러 프로세스 또는 스레드가 자원을 공유하는 상황에서 하나의 프로세스 또는 스레드만 접근할 수 있도록 제한해둔 영역입니다.

</div>
</details>
<br />

<details>
   <summary> <b>8. </b> 임계 영역을 해결하는 방법은 주로 3가지가 존재합니다. 면접자 분께서는 어떤 방법을 통해 해결할 것이며 그 방법에 대해 설명해주세요.  </summary> <br />
<div>
   
- 임계영역을 해결하는 방법 중에는 Mutex가 있습니다.
- Mutex는 프로세스, 스레드가 공유자원을 lock()을 통해 잠금하고, 사용한 후에는 unlock()을 통해 잠금을 해제하는 객체를 말합니다.
  
</div>
</details>
<br />

<details>
   <summary> <b>9. </b> Thread-Safe에 대해 간단히 설명해주세요.   </summary> <br />
<div>

   - 하나의 함수가 한 스레드로부터 호출되어 실행 중일때,  
     다른 스레드가 그 함수를 호출하여 동시에 함께 실행되어도 각 스레드에서 함수의 수행 결과가 올바르게 나오는 것을 말합니다.
  
</div>
</details>
<br />

### 정효인
<details>
   <summary> <b>1. </b> CPU 스케쥴링 방법 중 한가지를 설명해주세요. </summary> <br />
<div>
   
  - 하나의 프로세스가 CPU를 차지하고 있어도 우선순위가 높은 다른 프로세스가 대기하는 경우 현재 프로세스를 중단 시키고 우선순위가 높은 프로세스에게 CPU를 할당하는 선점 스케쥴링 방법 중 라운드 로빈(RB)방법에 대해 설명하겠습니다.
  - 라운드 로빈은 각 프로세스가 동일한 할당 시간을 갖게되고 할당 시간이 지나고 나면 ready queue 맨 끝으로 가서 다시 CPU의 할당을 기다는 방법입니다.

</div>
</details>
<br />

<details>
   <summary> <b>2. </b> 멀티프로세스와 멀티스레드에 대해 설명해주세요. </summary> <br />
<div>
   
   - 멀티 프로세스는 하나의 프로세스가 죽더라도 다른 프로세스에 영향을 주지 않아 안정성이 높지만, 멀티 스레드보다 많은 메모리공간과 CPU 시간을 차지하는 단점이 있다.
   - 멀티 스레드는 멀티 프로세스보다 적은 메모리 공간을 차지하고 Context Switching이 빠른 장점이 있지만, 동기화 문제와 하나의 스레드 장애로 전체 스레드가 종료 될 위험을 갖고 있다.

</div>
</details>
<br />

<details>
   <summary> <b>3. </b> 전체적인 프로그램 실행방법에 대해 설명해주세요. </summary> <br />
<div>
   
   1. **전처리기**에 의한 치환 작업  
   2. **컴파일러**가 **기계어**로 번역(CPU의 명령어로 번역)  
   3. **어셈블러**가 기계어를 **바이너리 코드** 생성(CPU의 명령어를 바이너리 코드로 번역)  
   4. **링커**에 의한 연결과 결합(라이브러리와의 결합)  
   5. **로더**에 의해서 실행 가능한 파일을 메모리에 적재  
   6. 명령어를 CPU에 올려주고 **CPU에서 명령어 실행**  

</div>
</details>
<br />

<details>
   <summary> <b>4. </b> 메모리단편화에 대해 설명해주세요. </summary> <br />
<div>
   
   프로그램을 실행할 때 메모리에 올리고 실행을 하는데 이때 메모리 공간이 작은 조각 공간으로 나뉘게 될 경우, 사용 가능한 메모리가 충분함에도 불구하고 메모리 할당이 불가능한 상태가 발생하게 되는데, 이를 메모리 단편화라고 합니다.

</div>
</details>
<br />

<details>
   <summary> <b>5. </b> 메모리풀에 대해 장단점을 포함해서 설명해주세요. </summary> <br />
<div>
   
  - 필요한 메모리 공간을 필요한 크기, 개수 만큼 **사용자가 직접 지정하여 미리 할당받아 놓고 필요할 때마다 사용하고 반납**하는 기법입니다.
  - 미리 공간을 할당해놓고 가져다 쓰고 반납하기 때문에 할당과 해제로 인한 **외부 단편화가 발생하지 않고** 필요한 크기만큼 할당을 해놓기 때문에 **내부 단편화 또한 생기지 않는다**는 장점이 존재합니다.
  - 하지만 메모리 단편화로 인한 메모리 낭비량보다 메모리 풀을 만들었지만 쓰지 않았을 때 메모리 양이 커질 경우 사용하지 않아야 한다는 단점이 존재합니다.

</div>
</details>
<br />

<details>
   <summary> <b>6. </b> 블록킹과 논블록킹에 대해 설명해주세요. </summary> <br />
<div>
   
- 블록킹은 **다른 함수가 작업을 하지 못하도록 제어권을 계속 가지고 있는 것**으로 요청한 작업을 마칠 때까지 계속 대기하며 return 값을 받을 때까지 계속 대기하는 것 입니다.
- 논블록킹은 **호출된 함수가 자신의 할일을 모두 마치지 않더라도 바로 제어권을 리턴해주는 것**으로 요청한 작업을 즉시 마칠 수 없다면 즉시 return 하고  Thread 관점으로 본다면, 하나의 Thread가 여러 개의 IO를 처리가 가능합니다.

</div>
</details>
<br />

<details>
   <summary> <b>7. </b> 동기식 입출력(I/O) 과정에 대해 간단하게 설명해주세요. </summary> <br />
<div>
   
1. I/O가 진행되는 동안 다음 명령을 수행하지 않고 기다린다.
2. I/O 상태의 프로세스는 blocked state로 전환된다.
3. I/O가 완료되면 인터럽트를 통해 완료를 알린다. 이후 CPU의 제어권이 기존 프로그램에게 넘어간다.
4. blocked state의 프로세스는 wait 상태로 돌아간다.

</div>
</details>
<br />

<details>
   <summary> <b>8. </b> 데드락의 발생조건 4가지와 해결방법 1가지를 설명해주세요. </summary> <br />
<div>
   
데드락의 발생조건은 상호배제, 점유와 대기, 비선점, 순환대기 이렇게 4가지 입니다. 
해결방법은 은행원 알고리즘을 사용하여 프로세스가 자원을 요구할 때, 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지 사전에 검사하여 해결합니다.

</div>
</details>
<br />

<details>
   <summary> <b>9. </b> Spin Lock에 대해 설명해주세요. </summary> <br />
<div>
   
다른 스레드가 lock을 소유하고 있는 상황이라면 lock이 반환될 때까지 계속 확인하며 대기하는 것을 말한다.

</div>
</details>
<br />

### 황주원
<details>
   <summary> <b>1. </b> 운영체제에 대해 설명해주세요. </summary> <br />
<div>

   - 시스템의 자원과 동작을 관리하는 소프트웨어입니다. <br />
   - 프로세스, 저장장치, 네트워킹, 사용자, 하드웨어 등을 관리합니다. <br />

</div>
</details>
<br />

<details>
   <summary> <b>2. </b> 메모리 구조에 대해 설명해주세요. </summary> <br />
<div>

   - 메모리 구조는 4가지 종류가 있습니다. Code, Data, Heap, Stack이 있습니다. <br />
   - Code는 소스코드가 들어가는 부분, <br />
   - Data는 전역변수, 정적변수가 할당되는 부분, <br />
   - Heap은 사용자가 직접 관리하는 영역으로 데이터가 동적으로 할당되는 부분, <br />
   - Stack은 함수의 호출정보, 지역변수, 매개변수들이 저장되게 됩니다. <br />

</div>
</details>
<br />

<details>
   <summary> <b>3. </b> 프로세스와 스레드에 대해 설명해주세요. </summary> <br />
<div>

   - 프로세스는 실행중인 프로그램이고, 스레드는 프로세스 안에서 실행되는 흐름 단위 입니다. <br />
   - 프로세스는 **메모리와 CPU를 프로세스마다** 할당받아서 사용하는데 <br />
   - 스레드는 프로세스 안에서 다른 스레드와 **메모리와 CPU를 공유**해서 사용합니다. <br />

</div>
</details>
<br />

<details>
   <summary> <b>4. </b> 페이지 부재를 해결하는 과정의 절차를 설명해주세요. </summary> <br />
<div>

   - 운영체제가 페이지 부재를 해결하는 과정을 **요구 페이징**이라고 합니다. <br />
   - 요구 페이징을 수행하는 과정을 다음과 같습니다. <br />

   1. CPU 는 물리메모리를 확인하여 페이지가 없으면 trap을 발생하여 운영체제에 알립니다. <br />
   2. 운영체제는 CPU의 동작을 잠시 멈춥니다. <br />
   3. 운영체제는 페이지테이블을 확인하여 가상 메모리에 페이지가 존재하는 확인하고 없으면 프로세스를 중단합니다. <br />
   4. 페이지 폴트이면, 현재 물리 메모리에 비어있는 프레임이 있는지 찾습는다. <br />
   5. 비어있는 프레임에 해당 페이지를 로드하고, 페이지 테이블을 최신화합니다. <br />
   6. 중단되었던 CPU를 다시 시작합니다. <br />

</div>
</details>
<br />

<details>
   <summary> <b>5. </b> 함수 호출과 시스템 콜의 차이에 대해 설명해주세요. </summary> <br />
<div>

   - 운영체제가 페이지 부재를 해결하는 과정을 **요구 페이징**이라고 합니다. <br />
   - 함수호출은 자신이 작성한 함수 혹은 라이브러리에 저장된 함수를 호출하는 것입니다. <br />
   - 시스템 콜은 운영체제에 정의된 함수를 호출하는 것입니다. <br />

</div>
</details>
<br />

<details>
   <summary> <b>6. </b> 인터럽트와 시스템 콜의 차이에 대해 설명해주세요. </summary> <br />
<div>

   - 인터럽트는 프로그램 실행 중 예기치 않은 상황으로 지금 실행 중인 작업을 중단하고, 다른 처리를 진행하는 것입니다. <br />
   - 하드웨어 인터럽트와 소프트웨어 인터럽트가 있습니다.  <br />
   - 시스템 콜은 이 중 소프트웨어 인터럽트로 사용자 모드가 커널 영역을 기능을 사용할 수 있게 해주는 것입니다. <br />

</div>
</details>
<br />

<details>
   <summary> <b>7. </b> 동기와 비동기에 대해 설명해주세요. </summary> <br />
<div>

   - 동기와 비동기는 호출되는 함수의 작업 완료 여부를 신경쓰냐가 관심사입니다. <br />
   - 동기는 작업 완료 여부를 호출하는 함수가 계속 확인합니다.  <br />
   - 비동기는 호출하는 함수는 작업 완료 여부를 신경쓰지 않는다.  <br />

</div>
</details>
<br />

<details>
   <summary> <b>8. </b> 프로세스 제어 블록, PCB에 대해 설명해주세요. </summary> <br />
<div>

   - 프로세스 제어 블록은 특정 프로세스에 대한 중요한 정보를 저장하고 있는 운영체제의 자료구조입니다. <br />
   - 프로세스는 생성과 동시에 고유한 PCB를 생성합니다.  <br />

</div>
</details>
<br />

<details>
   <summary> <b>9. </b> 폴링과 인터럽트의 차이점을 설명해주세요. </summary> <br />
<div>

   - 인터럽트는 외부의 인터럽트 핀에 신호가 들어오면 즉시 인터럽트 소스를 실행하고 다시 원래의 코드로 돌아오는 방식입니다. <br />
   - 폴링은 특정 주기마다 스레드를 돌면서 시그널이 들어왔는지 확인하는 방식입니다.  <br />
</div>
</details>
<br />
